package services

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	db "github.com/rishabhkanojiya/orbitdeck/server/core/db/sqlc"
	"gopkg.in/yaml.v3"
)

// HelmDeployer defines the interface for Helm deployment operations
type HelmDeployer interface {
	Deploy(deployment db.Deployment) error
}

// HelmService handles Helm chart operations
type HelmService struct {
	chartPath   string        // Path to Helm charts directory
	kubeconfig  string        // Path to kubeconfig file
	helmTimeout time.Duration // Timeout for Helm operations
	logger      Logger        // Custom logger interface
}

type Logger interface {
	Info(msg string)
	Error(msg string, err error)
}

// NewHelmService creates a new Helm service
func NewHelmService(chartPath, kubeconfig string, logger Logger) *HelmService {
	return &HelmService{
		chartPath:   chartPath,
		kubeconfig:  kubeconfig,
		helmTimeout: 5 * time.Minute,
		logger:      logger,
	}
}

// Deploy handles the Helm deployment process
func (s *HelmService) Deploy(deployment db.Deployment) error {
	// Generate values.yaml content from deployment
	values, err := s.generateValues(deployment)
	if err != nil {
		return fmt.Errorf("failed to generate Helm values: %w", err)
	}

	// Create temporary values file
	valuesPath, err := s.createValuesFile(values)
	if err != nil {
		return fmt.Errorf("failed to create values file: %w", err)
	}
	defer os.Remove(valuesPath)

	// Build Helm command arguments
	args := []string{
		"upgrade", "--install",
		deployment.HelmRelease.String,
		filepath.Join(s.chartPath, "orbit-base"),
		"-f", valuesPath,
		"-n", "orbit",
		"--create-namespace",
		"--kubeconfig", s.kubeconfig,
		"--wait",
		"--timeout", s.helmTimeout.String(),
	}

	// Execute Helm command
	ctx, cancel := context.WithTimeout(context.Background(), s.helmTimeout)
	defer cancel()

	cmd := exec.CommandContext(ctx, "helm", args...)

	// Capture output for logging
	output, err := cmd.CombinedOutput()
	if err != nil {
		s.logger.Error("Helm command failed", fmt.Errorf("%s: %s", err, string(output)))
		return fmt.Errorf("helm deployment failed: %w\n%s", err, string(output))
	}

	s.logger.Info(fmt.Sprintf("Helm deployment successful for %s\n%s",
		deployment.HelmRelease, string(output)))
	return nil
}

// generateValues creates the Helm values structure from the deployment
func (s *HelmService) generateValues(deployment db.Deployment) (map[string]interface{}, error) {
	components := make([]map[string]interface{}, 0, len(deployment.Components))

	for _, comp := range deployment.Components {
		componentValues := map[string]interface{}{
			"name":         comp.Name,
			"replicaCount": comp.ReplicaCount,
			"image": map[string]string{
				"repository": comp.Image.Repository,
				"tag":        comp.Image.Tag,
			},
			"resources": map[string]interface{}{
				"requests": map[string]string{
					"cpu":    comp.Resources.Requests.CPU,
					"memory": comp.Resources.Requests.Memory,
				},
				"limits": map[string]string{
					"cpu":    comp.Resources.Limits.CPU,
					"memory": comp.Resources.Limits.Memory,
				},
			},
			"service": map[string]interface{}{
				"port": comp.ServicePort,
			},
			"env": comp.Env,
		}

		components = append(components, componentValues)
	}

	return map[string]interface{}{
		"components":  components,
		"environment": deployment.Environment,
	}, nil
}

// createValuesFile creates a temporary values.yaml file
func (s *HelmService) createValuesFile(values map[string]interface{}) (string, error) {
	data, err := yaml.Marshal(values)
	if err != nil {
		return "", fmt.Errorf("failed to marshal values: %w", err)
	}

	tmpFile, err := os.CreateTemp("", "helm-values-*.yaml")
	if err != nil {
		return "", fmt.Errorf("failed to create temp file: %w", err)
	}
	defer tmpFile.Close()

	if _, err := tmpFile.Write(data); err != nil {
		return "", fmt.Errorf("failed to write values file: %w", err)
	}

	return tmpFile.Name(), nil
}

// VerifyHelmInstallation checks if Helm is installed and working
func (s *HelmService) VerifyHelmInstallation() error {
	cmd := exec.Command("helm", "version")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("helm not installed or not working properly: %w\n%s", err, string(output))
	}
	s.logger.Info("Helm version:\n" + string(output))
	return nil
}
